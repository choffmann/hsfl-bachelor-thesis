# Fazit
In dieser Arbeit haben wir uns mit JavaScript, TypeScript und WebAssembly beschäftigt. JavaScript ist eine dynamisch typisierte Programmiersprache für die Webentwicklung. TypeScript ist eine Erweiterung von JavaScript und bietet eine strikte Typisierung. WebAssembly ist ein Low-Level-Kompilierungsziel für verschiedene Sprachen und hat das Ziel, schnell, sicher, portabel und kompakt zu sein. Frühere Konzepte wie ActiveX, NativeClient oder `asm.js` konnten diese Ziele nicht erreichen. Wir haben uns WebAssembly an einem konkreten Beispiel angeschaut und eine JavaScript-Funktion in WebAssembly umgeschrieben. Dabei haben wir uns die Geschichte des Webbrowsers angesehen und die Unterschiede zwischen client- und serverseitigen Anwendungen sowie die Rolle von WebAssembly erläutert. Wir haben ein Beispiel von Figma gesehen, wie sie erfolgreich von `asm.js` auf WebAssembly umgestellt haben und welche Vorteile Figma berichtet. Wir haben uns die Definition eines Just-In-Time Compilers angeschaut und sind detailliert durch die einzelnen Komponenten der JavaScript Engine von V8 gegangen, wie den Parser, Ignition, TurboFan, Orinoco, den WebAssembly-Compiler Liftoff und warum eine Funktion in JavaScript deoptimiert wird, wenn sie bereits optimiert wurde. Es wurde geplant, wie ein Leistungsvergleich zwischen WebAssembly, JavaScript und TypeScript mittels spezifischer Referenzalgorithmen durchgeführt wird. Es wurden Forschungsfragen aufgestellt, um zu untersuchen, ob WebAssembly immer eine schnellere Ausführungszeit als JavaScript und TypeScript aufweist, wie groß der quantitative Unterschied in der Ausführungszeit zwischen WebAssembly zu JavaScript und TypeScript ist und ob WebAssembly in verschiedenen Webbrowsern eine gleiche Ausführungszeit aufweist. Es wurde erklärt, was ein Benchmark ist und wie die Performance definiert wird. Es wurde definiert, dass die Metriken der Ausführungszeit gemessen werden, da die Messung des Speicherverbrauchs in Webbrowsern inkonsistent ist. Als Benchmark-Algorithmen wurden die Matrizenmultiplikation und die Berechnung der Mandelbrotmenge ausgewählt. Die Matrizenmultiplikation ist eine wichtige Funktion von computergenerierten Grafiken und die Mandelbrotmenge ist ein bekannter Vergleichsalgorithmus von _The Computer Language Benchmarks Game_. In dieser Arbeit beschäftigten wir uns damit, wie die Benchmark-Algorithmen mathematisch definiert sind. Um einen guten Durchschnitt der Laufzeiten zu erhalten, planten wir, den Benchmark mehrmals auszuführen und wie die Zeitmessung erfolgt. Außerdem erläuterten wir die Qualitätskriterien von Benchmarks und zeigten, wie sie erfüllt werden. Die ausgewählten Benchmarks wurden in TypeScript, JavaScript und Rust für WebAssembly programmiert. Ein Frontend wurde entwickelt, um die Benchmarks einfach ausführen zu können. Es wird gezeigt, wie der Versuch in einer Laborumgebung aufgebaut wurde. Dazu wurden zwei Testcomputer neu eingerichtet, um ein frisch installiertes Betriebssystem zu bieten. Die Spezifikationen der Versuchscomputer sowie die verwendeten Webbrowser wurden beschrieben. Um sicherzustellen, dass die Versuchscomputer die Benchmarks über das Frontend ausführen können, ohne dass der Webserver auf den Versuchscomputern läuft, wurde ein externen Webserver eingerichtet. Die Anwendung ist über die URL `https://benchmark.choffmann.io/` verfügbar. Nach jeder vollständigen Durchführung von JavaScript, TypeScript und WebAssembly wurde der Bericht heruntergeladen, der Browsercache gelöscht und der Versuch erneut durchgeführt. Insgesamt wurde jeder Benchmark pro Sprache und Webbrowser dreimal ausgeführt. Um die erhaltenen Zeitmessungen zu vergleichen, wurde eine Durchschnittsmenge der Ausführungszeiten berechnet und aufgelistet. Anschließend wurden die unterteilten Forschungsfragen RQ1, RQ2 und RQ3 beantwortet. Es wurde festgestellt, dass WebAssembly in allen Ausführungen eine höhere Geschwindigkeit aufweist. Bei der Matrizenmultiplikation unter Linux ist WebAssembly im Durchschnitt um 55% - 77% und auf dem MacBook um 52% - 68% schneller als JavaScript und TypeScript. Bei der Mandelbrotmenge haben wir auf dem Linux-System eine durchschnittliche Geschwindigkeitssteigerung von 26% bis 91% festgestellt. Auf dem MacBook war die Ausführungszeit im Durchschnitt um 0,95% bis 87% schneller. Wir haben festgestellt, dass der Mandelbrotmenge-Algorithmus in JavaScript auf dem MacBook in Chrome sehr schnell ausgeführt wird. Die Ausführungszeiten für denselben Code in JavaScript und TypeScript variieren jedoch stark zwischen den verschiedenen Webbrowsern. Durch die Unterfrage RQ3 haben wir ermittelt, dass WebAssembly in allen Webbrowsern eine gleiche Ausführungszeit aufweist. Es gab jedoch signifikante Unterschiede zwischen Chrome und Firefox sowie zwischen Safari und Firefox bei der Ausführung des Mandelbrotmenge-Algorithmus auf dem Macbook. Wir vermuten, dass dies auf einen fehlerhaften Testdruchlauf zurückzuführen ist und haben empfohlen, den Test zu wiederholen. Wir sind zu dem Schluss gekommen, dass WebAssembly wie erwartet eine Leistungsverbesserung gegenüber JavaScript und TypeScript bietet. Es wurde festgestellt, dass der JavaScript-Code in verschiedenen Webbrowsern unterschiedliche Ausführungszeiten aufweist, was in der Programmierung hinderlich sein kann. Dieses Problem wird bekämpft, da WebAssembly in allen Webbrowsern gleich schnell ausgeführt wird. Um diese Arbeit fortzuführen, könnten Sprachen verglichen werden, die zu WebAssembly kompilieren können, jedoch einen Garbage Collector benötigen. Dazu gehören Sprachen wie Java, Kotlin, Dart, Python und C#. Für diese Sprachen wurde der WasmGC entwickelt, das als experimentelles Feature behandelt wird. Seit Anfang November 2023 ist das Feature vollständig in Chrome 119 integriert und Ende November 2023 wurde WasmGC in Firefox Version 120 integriert. Safari unterstützt den WasmGC noch nicht [@zakai_new_2023; @mozilla_firefox_2023; @webassembly_community_feature_nodate].

